Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 数据结构

## 链表
- NOTE
<pre>提供了在常数时间内的 addAtHead 和 addAtTail 操作</pre>

### 链表分类
> collapsed=`true`


#### 单链表\(最简单\)

#### 双链表\(最常用\)：优化了插入和删除
> collapsed=`true`


##### Java中的LinkedList

##### 双向链表的双向搜索
- NOTE
<pre>我们可以从头部或尾部进行搜索</pre>

#### 多重链表

### 链表构造
> collapsed=`true`


#### 如何构造单链表?
> collapsed=`true`


##### 基本要素
> collapsed=`true`


###### 单链节点
> collapsed=`true`


####### 每个节点包括：值\+链接到下一个元素的指针

###### 三类3种节点
> collapsed=`true`


####### 关联节点
> collapsed=`true`


######## 单链表需要一个前驱节点

######## 双链表需要两个

####### 目标节点

####### 哨兵节点
> collapsed=`true`

- NOTE
<pre>（数和链表中广泛使用）

哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。

我们将使用伪头来简化我们简化插入和删除</pre>

######## 单链表需要一个伪头节点

######## 双链表需要两个

###### 链表长度

##### 关键点\(添加和删除操作\)
> collapsed=`true`


###### 添加和删除两个操作中, 如何找到节点的前驱?
> collapsed=`true`


####### 通过索引\(注意索引与链表长度的关系\)

###### 如何将"目标节点", 进行添加和删除等操作呢?
> collapsed=`true`


####### 通过节点的next指针

##### 功能\(方法\)
> collapsed=`true`


###### 添加node
> collapsed=`true`


####### 参数: 索引 \+ 值
> collapsed=`true`


######## 链表首添加, 无须传入索引

###### 删除node
> collapsed=`true`


####### 参数: 索引

###### 获取node
> collapsed=`true`


####### 参数: 索引

#### 如何构造双链表?\(区别于循环链表\)
> collapsed=`true`


##### 基本要素
> collapsed=`true`


###### 双链节点
> collapsed=`true`


####### 每个节点包括: 值 \+ 指向前一个元素的指针 \+ 指向后一个元素的指针

###### 三类5种节点
> collapsed=`true`


####### 关联节点
> collapsed=`true`


######## 后继节点

######## 前驱节点

####### 目标节点

####### 哨兵节点
> collapsed=`true`


######## 伪头哨兵

######## 伪尾哨兵

##### 关联点\(添加和删除操作\)
> collapsed=`true`


###### 添加和删除两个操作中, 如何找到节点的前驱和后继?
> collapsed=`true`


####### 通过遍历索引\(注意根据索引与链表/2长度的关系\)
> collapsed=`true`


######## 从前往后遍历

######## 从后往前遍历

###### 如何将"目标节点",进行添加和删除等操作呢?

##### 功能\(方法\)
> collapsed=`true`


###### 添加node
> collapsed=`true`


####### 参数: 索引 \+ 值
> collapsed=`true`


######## 链表首尾添加, 无须传入索引

###### 删除node
> collapsed=`true`


####### 参数: 索引

###### 获取node
> collapsed=`true`


####### 参数: 索引

### 链表应用

## 数组

### 数组底层
> collapsed=`true`


#### 底层实现\(依赖JVM机制,这里不做讨论\)
> collapsed=`true`


##### 只需要知道,数组是一块地址连续,不定长的内存空间

#### 基本要素
> collapsed=`true`


##### 索引（下标）和长度

##### 数组存放的值

### 数组操作
> collapsed=`true`


#### 4种操作
> collapsed=`true`


##### 增
> collapsed=`true`


###### 加末尾,直接增

###### 加其他位置, 需要逐个"腾地方"

##### 删
> collapsed=`true`


###### 删除末尾,直接删

###### 删其他位置, 需要逐个"填补"上去

##### 改

##### 查

#### 单个数组的考察操作
> collapsed=`true`


##### 数组去重

##### 数组排序

##### 元素移动

##### 元素转换

#### 多个数组间的考查操作
> collapsed=`true`


##### 数组合并

### 二维数组
> collapsed=`true`


#### 二维数组操作
> collapsed=`true`


##### 矩阵问题
> collapsed=`true`


###### 矩阵旋转

###### 对角线遍历

###### 子矩阵

## 字符串

### 字符串底层

### 字符串操作

#### 整个字符串作为操作对象
- NOTE
<pre>
字符串的基本操作对象通常是字符串整体或其子串:


例如有这样一个字符串序列：I like leetcode 现在你想把这句话反向输出，可能会变成这样：

edocteel ekil I

这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：

Leetcode like I</pre>

##### 字符串之间的比较操作

###### 可以用"=="吗?

####### Java不可用

####### Python/C\+\+可以

##### 字符串之间的连接操作

###### 可以用"\+"吗?

##### 字符串间的匹配操作

###### KMP算法

###### BM算法

#### 将子串作为操作对象

##### 前缀

##### 后缀
