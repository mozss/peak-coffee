Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 数据结构体系
- NOTE
<pre>数据结构本质上是一种抽象的表达。数据结构可以理解为“物理结构”和“逻辑结构”，在计算机中
“物理结构”就对应着“内存结构”，内存可以理解为紧密排布的小格子。

最基本的逻辑结构就是数组和链表，这两种结构也很容易理解，思维理解上更像物理结构。

其他的逻辑结构都可以用这两种基本的结果进行描述。比如堆栈，树等结构的构造和存储都可以依赖
数组和链表。</pre>

## 学习方法
> textColor=`#FF0000`


### 把握分类
> textColor=`#FF0000`


### 懂得构造
> textColor=`#FF0000`


#### 基本元素
> textColor=`#FF0000`


#### 构造的关键点
> textColor=`#FF0000`


#### 主要的方法
> textColor=`#FF0000`


### 熟练使用
> textColor=`#FF0000`


## 链表
> collapsed=`true`

- NOTE
<pre>提供了在常数时间内的 addAtHead 和 addAtTail 操作</pre>

### 链表分类
> collapsed=`true`


#### 单链表\(最简单\)

#### 双链表\(最常用\)：优化了插入和删除操作
> collapsed=`true`


##### Java中的LinkedList

##### 利用了双向链表的双向搜索
- NOTE
<pre>我们可以从头部或尾部进行搜索, 也就是通过双指针的方式,</pre>

#### 循环链表

#### 多重链表（链表的结点隶属多个链表）

### 链表构造
> collapsed=`true`


#### 如何构造单链表?
> collapsed=`true`


##### 基本要素
> collapsed=`true`


###### 单链表节点
> collapsed=`true`


####### 每个节点包括：值\+链接到下一个元素的指针

###### 三类3种节点
> collapsed=`true`


####### 关联节点
> collapsed=`true`


######## 单链表需要一个前驱节点

######## 双链表需要两个

####### 目标节点

####### 哨兵节点
> collapsed=`true`

- NOTE
<pre>（数和链表中广泛使用）

哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。

我们将使用伪头来简化我们简化插入和删除</pre>

######## 单链表需要一个伪头节点

######## 双链表需要两个

###### 链表长度

##### 关键点\(添加和删除操作\)
> collapsed=`true`


###### 添加和删除两个操作中, 如何找到节点的前驱?
> collapsed=`true`


####### 通过索引\(注意索引与链表长度的关系\)

###### 如何将"目标节点", 进行添加和删除等操作呢?
> collapsed=`true`


####### 通过节点的next指针

##### 功能\(方法\)
> collapsed=`true`


###### 添加node
> collapsed=`true`


####### 参数: 索引 \+ 值
> collapsed=`true`


######## 链表首添加, 无须传入索引

###### 删除node
> collapsed=`true`


####### 参数: 索引

###### 获取node
> collapsed=`true`


####### 参数: 索引

#### 如何构造双链表?\(区别于循环链表\)
> collapsed=`true`


##### 基本要素
> collapsed=`true`


###### 双链表节点
> collapsed=`true`


####### 每个节点包括: 值 \+ 指向前一个元素的指针 \+ 指向后一个元素的指针

###### 三类5种节点
> collapsed=`true`


####### 关联节点
> collapsed=`true`


######## 后继节点

######## 前驱节点

####### 目标节点

####### 哨兵节点
> collapsed=`true`


######## 伪头哨兵

######## 伪尾哨兵

###### 链表的长度

##### 关键点\(添加和删除操作\)
> collapsed=`true`


###### 添加和删除两个操作中, 如何找到节点的前驱和后继?
> collapsed=`true`


####### 通过遍历索引\(注意根据索引与链表/2长度的关系\)
> collapsed=`true`


######## 从前往后遍历

######## 从后往前遍历

###### 如何将"目标节点",进行添加和删除等操作呢?

##### 功能\(方法\)
> collapsed=`true`


###### 添加node
> collapsed=`true`


####### 参数: 索引 \+ 值
> collapsed=`true`


######## 链表首尾添加, 无须传入索引

###### 删除node
> collapsed=`true`


####### 参数: 索引

###### 获取node
> collapsed=`true`


####### 参数: 索引

### 链表应用

## 数组
> collapsed=`true`


### 数组底层
> collapsed=`true`


#### 底层实现\(依赖JVM机制,这里不做讨论\)
> collapsed=`true`


##### 只需要知道,数组是一块地址连续,不定长的内存空间

#### 基本要素
> collapsed=`true`


##### 索引（下标）和长度

##### 数组存放的值

### 数组操作
> collapsed=`true`


#### 4种操作
> collapsed=`true`


##### 增
> collapsed=`true`


###### 加末尾,直接增

###### 加其他位置, 需要逐个"腾地方"

##### 删
> collapsed=`true`


###### 删除末尾,直接删

###### 删其他位置, 需要逐个"填补"上去

##### 改

##### 查

#### 单个数组的考察操作
> collapsed=`true`


##### 数组去重

##### 数组排序

##### 元素移动

##### 元素转换

#### 多个数组间的考查操作
> collapsed=`true`


##### 数组合并

### 二维数组
> collapsed=`true`


#### 二维数组操作
> collapsed=`true`


##### 矩阵问题
> collapsed=`true`


###### 矩阵旋转

###### 对角线遍历

###### 子矩阵

## 字符串
> collapsed=`true`


### 字符串底层

### 字符串操作
> collapsed=`true`


#### 整个字符串作为操作对象
> collapsed=`true`

- NOTE
<pre>
字符串的基本操作对象通常是字符串整体或其子串:


例如有这样一个字符串序列：I like leetcode 现在你想把这句话反向输出，可能会变成这样：

edocteel ekil I

这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：

Leetcode like I</pre>

##### 字符串之间的比较操作
> collapsed=`true`


###### 可以用"=="吗?
> collapsed=`true`


####### Java不可用

####### Python/C\+\+可以

##### 字符串之间的连接操作
> collapsed=`true`


###### 可以用"\+"吗?

##### 字符串间的匹配操作
> collapsed=`true`


###### KMP算法
> collapsed=`true`


####### https://leetcode\-cn\.com/leetbook/read/array\-and\-string/cpoo6/

###### BM算法

#### 将子串作为操作对象
> collapsed=`true`


##### 前缀

##### 后缀

## 哈希
> collapsed=`true`


### 哈希底层
> collapsed=`true`


#### 分类
> collapsed=`true`


##### 哈希集合\(非重复值\)

##### 哈希映射\(key\-value\)

#### 哈希实现
> collapsed=`true`


##### 哈希函数
> collapsed=`true`

- NOTE
<pre>1. 当我们要插入一个新的键的时候, 哈希函数将决定该键应该分配到哪个桶, 并将该键存储到相应
的桶中;

2.当我们想要搜索一个键时, 哈希表将使用相同的哈希函数来查找对应的桶, 并只在特定的桶中
进行搜索.</pre>

###### 将键映射到存储桶

##### 冲突处理
> collapsed=`true`


###### 链地址
- NOTE
<pre>为每个哈希值维护一个链表, 并将具有相同哈希值的元素都放入这一链表中.</pre>

###### 开放地址
- NOTE
<pre>当发现哈希值h处产生一个冲突时, 根据某种策略, 从h出发找到下一个不冲突的位置.

例如, 一种比较简单的策略, 不断检查h + 1, ,h +2, h + 3,...这些整数对应的位置.

</pre>

###### 再哈希
- NOTE
<pre>当发现哈希冲突之后, 使用另一个哈希函数产生一个新的地址</pre>

##### 扩容
- NOTE
<pre>当哈希表元素过多的时候, 冲突的概率会越来越大, 而在哈希表中查询一个元素的效率也会越来越低. 
因此, 需要开辟一块更大的空间, 来缓解哈希表中发生的冲突.</pre>

### 哈希表构造
> collapsed=`true`


#### 基本要素
> collapsed=`true`


##### 哈希函数
> collapsed=`true`

- NOTE
<pre>哈希函数的设计是一个开发的问题, 各种语言都有不同的实现方式。

但主要的思想就是尽可能将键分配到桶中，理想情况下，
完美的哈希函数将键和桶之间的一对一映射。

然后， 在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。
也就是说， 我们需要处理冲突。（多个值分配到一个桶，这就是一个冲突）</pre>

###### 键值的范围

###### 桶的数量

###### 冲突解决算法面对的问题
> collapsed=`true`


####### 1\.如何组织在同一个桶中的值？

####### 2\.如果为同一个桶分配了太多的值，该怎么办？

####### 3\.如何在特定的桶中搜索目标值？

##### 桶
> collapsed=`true`


###### 单个桶的容量N
> collapsed=`true`


####### N是常数且比较小
> collapsed=`true`


######## 使用数组

####### N是可变或很大
> collapsed=`true`


######## 使用高度平衡的二叉树

#### 关键点（插入和搜索, 以及删除）
> collapsed=`true`


##### 删除
> collapsed=`true`


###### 两种解决方案
> collapsed=`true`

- NOTE
<pre>我们来看看 “删除” 操作。在找到元素的位置之后，我们需要从数组列表中删除元素。

假设我们要删除第 i 个元素，并且数组列表的大小为 n。

内置函数中使用的策略是把第 i 个元素后的所有元素向前移动一个位置。也就是说，你必须移动 n - i 次。
因此，从数组列表中删除元素的时间复杂度将为 O(n)。

考虑 i 取不同值的情况。平均而言，我们将移动((n - 1) + (n - 2) + ... + 1 + 0) / n = (n - 1) / 2 次。

希望有两种解决方案可以将时间复杂度从O(n)降低到 O(1)。
</pre>

####### 交换

####### 链表

#### 内置哈希表原理
- NOTE
<pre>内置哈希表的原理
内置哈希表的典型设计是：

键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有哈希码。
此哈希码将用于映射函数以获取存储区索引。

1.每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。
2.如果在同一个桶中有太多的值，这些值将被保留在一个高度平衡的二叉树搜索树中。
3.插入和搜索的平均时间复杂度仍为 O(1)。最坏情况下插入和搜索的时间复杂度是 O(logN)，
使用高度平衡的 BST。这是在插入和搜索之间的一种权衡。</pre>

### 哈希应用
> collapsed=`true`


#### 存储

#### 查重

### 实际应用
> collapsed=`true`


#### 哈希集合

#### 哈希映射
> collapsed=`true`


##### 按键聚合

##### 提供更多信息

#### 设计键

## 队列
> collapsed=`true`


### 实现方式
> collapsed=`true`


#### 数组实现

#### 单链表实现

### 构造链表
> collapsed=`true`


#### 如何构造单链表?

#### 如何构造循环链表?
> collapsed=`true`


##### 基本要素
> collapsed=`true`


###### 数组queue
> collapsed=`true`


####### 数组长度

###### 队列
> collapsed=`true`


####### 队列容量capacity\(通过数组长度可以得到, 但是用户使用频繁, 可以定义它\)

####### 元素个数/循环队列当前长度count

###### 指针
> collapsed=`true`


####### 队首指针headIndex

####### 无须队尾指针\(通过headIndex 和 count可以计算出, 所以不需要尾指针\)

##### 关键点
> collapsed=`true`


###### 通过首指针和队列长度, 可以计算出尾指针
> collapsed=`true`


####### tailIndex = \(headIndex \+ count \-1\) mod capacity

###### 数组长度和队列容量的关系
> collapsed=`true`


####### 当前元素个数count \<= 队列容量capacity

####### 插入的时
> collapsed=`true`


######## count == capacity ,不能插入

## 栈
> collapsed=`true`


### 实现方式
> collapsed=`true`


#### 动态数组

### 栈的运用
> collapsed=`true`


#### 入栈

#### 出栈

#### 获取顶部元素

## 二叉树

### 遍历
- NOTE
<pre>最简单的树
    根
  左···右
  
  
  遍历方式：
  1. 根-左-右
  2. 根-右-左
  
  3. 左-右-根
  4. 左-根- 右
  
  5. 右-根-左
  6. 右-左-根
  
  其实一个有6中, 但是我们按照&quot;先左后后&quot; &quot;以根为主&quot;两个原则, 
  我们可以把上面的6中简化为3种(前序-中序-后续), 这3种都是
  深度优先的遍历:
  
  (深度优先)
  前序遍历: 根-左-右
  中序遍历: 左-根-右
  后序遍历: 左-右-根
  
  (广度优先: 按层遍历)
  广度优先遍历而言, 没有前中后序之分: 给定一组已排序的子节点, 其&quot;广度优先&quot;遍历只有一种结果.
  广度优先会先访问离根节点最近的节点, 二叉树的广度优先, 其实就是按层遍历.
  
  
  </pre>

### 二叉树分类

### 构造二叉树

#### 普通二叉树

##### 基本元素

##### 构造的关键点

##### 主要的方法

### 使用二叉树

## 二叉搜索树
